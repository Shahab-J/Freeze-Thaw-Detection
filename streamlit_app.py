# -*- coding: utf-8 -*-
"""Chapter3_GEE_PythonAPI_23March2025_GitHub- Streamlit

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1y19IaZy-fJCSobhyB5XmP8V_m13uMKv5
"""

import ee
import geemap
import streamlit as st
import numpy as np
from datetime import date
import PIL.Image
import urllib.request

# Initialize Earth Engine
try:
    ee.Initialize()
except Exception:
    ee.Authenticate()
    ee.Initialize(project='ee-shahabeddinj')

# Streamlit title and description about the app
st.title("Freeze-Thaw Mapping Tool")
st.write("""
    This tool allows users to detect and analyze **freeze-thaw** states in agricultural lands using **Sentinel-1 SAR data** and **Random Forest classification**.
    The tool offers the ability to interactively define a region of interest (ROI) and specify a date range for processing.

    Key Features:
    - **Draw ROI on the Map**: Select your area of interest directly on the map.
    - **Date Range Selection**: Choose the time period for analysis.
    - **Resolution Selection**: Customize the resolution of the processed data.
    - **Cropland Masking**: Option to limit analysis to agricultural areas.
    - **Visualization**: View classified freeze-thaw maps for the selected dates.
""")

# ==========================================
# 🌍 **Step 1: Interactive Map for ROI Selection**
# ==========================================
Map = geemap.Map()
Map.add_basemap('SATELLITE')
Map.centerObject(ee.Geometry.Point([-72.75, 46.29]), 12)
Map.add_draw_control()

st.write("🔹 **Draw** your ROI on the map, then click **Submit** to start processing.")
st.map(Map)

# Date input widgets for selecting the range
start_date_widget = st.date_input('Start Date:', date(2023, 10, 1), min_value=date(2015, 1, 1), max_value=date(2025, 12, 31))
end_date_widget = st.date_input('End Date:', date(2024, 6, 30), min_value=date(2015, 1, 1), max_value=date(2025, 12, 31))

# Resolution dropdown for user to choose the resolution of the processed data
resolution_widget = st.selectbox('Resolution (m):', [10, 30, 100], index=1)

# Cropland clipping checkbox for agricultural areas only
clip_to_agriculture_checkbox = st.checkbox('Clip to Agricultural Lands Only (Class 15)')

# Submit button to trigger the processing pipeline
roi_button = st.button("Submit ROI & Start Processing")

# **Processing Function**
def submit_roi():
    user_roi = ee.Geometry(Map.user_roi)

    if user_roi is None:
        st.error("❌ No ROI selected. Please draw an ROI on the map.")
        return

    # Use the processing functions you already have:
    processed_images = process_sentinel1(start_date_widget, end_date_widget, user_roi)
    if processed_images is None:
        st.error("❌ No processed images available.")
        return

    # Count the number of images before mosaicking
    num_images_before_mosaic = processed_images.size().getInfo()
    st.write(f"🔍 **Found {num_images_before_mosaic} images before mosaicking.**")

    # Apply mosaicking
    mosaicked_images = mosaic_by_date(processed_images, user_roi, start_date_widget, end_date_widget)
    if mosaicked_images is None:
        st.error("❌ No mosaicked images found.")
        return

    # Count the number of images after mosaicking
    num_images_after_mosaic = mosaicked_images.size().getInfo()
    st.write(f"✅ **Found {num_images_after_mosaic} images after mosaicking.**")

    # Classify images
    classified_collection = classify_images(mosaicked_images)

    # Visualize classified images
    visualize_classified_images(classified_collection)

    # Compute and display statistics (frozen vs thawed)
    stats = summarize_statistics(classified_collection, user_roi)
    st.write(stats)

    st.success("Processing Completed. Data ready for visualization.")

# Trigger processing when the Submit button is clicked
if roi_button:
    submit_roi()

# ==========================================
# 📌 **Step 2: Classify Images**
# ==========================================
def classify_images(mosaicked_images):
    """Classifies images using the Random Forest model and adds the 'FT_State' band."""
    # Assume you already have a trained RF model and function for classification
    rf_model = train_rf_model()

    # Classify the mosaicked images
    classified_collection = mosaicked_images.map(lambda img: img.addBands(
        img.select('EFTA').classify(rf_model).rename('FT_State')
    ))

    return classified_collection

# ==========================================
# 📌 **Step 3: Visualize Classified Images**
# ==========================================
def visualize_classified_images(classified_collection):
    """Visualizes the classified images in the app."""
    # Visualize classified images (assuming you're displaying images as thumbnails or plots)
    image_list = classified_collection.toList(classified_collection.size())
    num_images = classified_collection.size().getInfo()

    for i in range(num_images):
        img = ee.Image(image_list.get(i))
        # Get the thumbnail URL for FT_State
        url = img.select('FT_State').getThumbURL({
            "min": 0, "max": 1, "dimensions": 512, "palette": ["blue", "red"]
        })
        # Show image in Streamlit
        image_array = np.array(PIL.Image.open(urllib.request.urlopen(url)))
        st.image(image_array, caption=f"Classified Image {i+1}", use_column_width=True)

# ==========================================
# 📌 **Step 4: Summarize Statistics (Frozen vs Thawed)**
# ==========================================
def summarize_statistics(classified_collection, user_roi):
    """Computes and returns a brief statistical summary of freeze-thaw classification."""
    selected_resolution = resolution_widget  # User-selected resolution

    image_list = classified_collection.toList(classified_collection.size())
    num_images = classified_collection.size().getInfo()

    summary = []

    for i in range(num_images):
        img = ee.Image(image_list.get(i))

        # Calculate freeze/thaw statistics
        stats = img.select("FT_State").reduceRegion(
            reducer=ee.Reducer.frequencyHistogram(),
            geometry=user_roi,
            scale=selected_resolution,
            maxPixels=1e13
        ).getInfo()

        hist = stats.get("FT_State", {})
        thawed_count = int(hist.get("0", 0))
        frozen_count = int(hist.get("1", 0))
        total_count = thawed_count + frozen_count
        thawed_percent = (thawed_count / total_count * 100) if total_count > 0 else 0
        frozen_percent = (frozen_count / total_count * 100) if total_count > 0 else 0

        summary.append(f"Image {i+1}: Frozen={frozen_count} ({frozen_percent:.1f}%) | Thawed={thawed_count} ({thawed_percent:.1f}%)")

    return "\n".join(summary)